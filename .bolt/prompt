# Monorepo Deployment Split: Contextual PDD

## Purpose
This document outlines the architectural refactor and deployment changes necessary to convert the current fullstack monorepo-based RAG document uploader into two independently deployed services: a backend (API) service deployed on Render, and a static frontend deployed to Vercel or Netlify.

## Background
Originally, the app was served as a unified monorepo where both backend and frontend were deployed under a single Render web service. However, this introduced routing and runtime issues (e.g., React frontend 404s, backend routes conflicting with static files). Splitting deployments avoids these issues.

## Goals
- Maintain monorepo architecture for local development.
- Deploy backend (FastAPI) as a web service to Render.
- Deploy frontend (React + Vite) as a static site to Vercel or Netlify.
- Share environment variables across services as needed.
- Use Supabase for user authentication, RLS, and vector storage.
- Integrate optional RunPod LLM embedding agent endpoint.

## New Directory Summary

```
/
├── backend/           # FastAPI service (deployed to Render)
├── frontend/          # React client (deployed to Vercel/Netlify)
├── supabase/          # Supabase migrations, config
├── package.json       # Dev tool scripts (npm run dev, lint, etc.)
```

## Services

### Backend API Service (Render)
- Framework: FastAPI
- Containerized: Yes (optional)
- Routes:
  - `POST /upload`
  - `GET /docs`
  - `POST /chat`
- Auth: Supabase JWT
- Needs `.env` vars:
  - `SUPABASE_URL`
  - `SUPABASE_KEY`
  - `SUPABASE_BUCKET`
  - `SUPABASE_JWT_SECRET`
  - `OPENAI_API_KEY` (optional)
  - `RUNPOD_EMBEDDING_URL` (optional)
  - `RUNPOD_EMBEDDING_KEY` (optional)

### Frontend Static Site (Vercel)
- Framework: React (Vite)
- Pages:
  - `/`: Landing / Login
  - `/dashboard`: Upload & document list
  - `/chat`: Query interface
  - `/agent`: Health/monitor
- Env vars:
  - `VITE_SUPABASE_URL`
  - `VITE_SUPABASE_ANON_KEY`
  - `VITE_API_URL` (Render backend endpoint)

## Design Constraints
- Maintain developer velocity through a unified monorepo with shared tools.
- Avoid CORS errors by ensuring VITE_API_URL matches deployed backend.
- Keep frontend backend-agnostic (talks only to API_URL).

## Risks
- Render cold-start latency for free-tier backends.
- Supabase vector limits or bandwidth constraints.
- RunPod must be reliable for long-lived pods (e.g. agent health monitoring).